# coding: utf-8

from . import *

def explore(genome, nodes, levels):
    """
    find the ancestors of a same level
    Start from a node (first level, such as the Output) and end at the input (last level)
    genome: networkx object, directed graph
    nodes: list with the first level
    levels: list of a list with the first level
        ex: explore(genome, ["Output"], [["Output"]])
    return a list where each element is a list with the nodes at a same level
    """
    parents = []
    for n in nodes: parents += genome.predecessors(n)
    if parents != []:
        levels += [parents]
        for j in range(1,len(levels)):
            z = set(levels[-1]) - set(levels[j-1])
            levels[-1] = list(z)
        return explore(genome, levels[-1], levels)
    else: return levels
    
def sort_levels(levels):
    """
    take the list generated by explore()
    and remove the redundancies to return a dict sorted by level
        key 0 = the output (or the first level with the element "nodes" given in explore())
        key n-th = the input
        ex: {0: ['Output'], 1: [2.1], 2: [1.1], 3: ['Input']}
    """
    N = len(levels)
    purged_lvs = []
    for i, lv in enumerate(levels):
        if i < N - 1:
            #make a flat list with superior levels
            flatted = [item for sublist in levels[i+1:] for item in sublist] 
            #compare values of a level with all values of superior levels and return values which are not in these levels
            s = set(lv) - set(flatted) 
        else: s = set(lv)
        purged_lvs += [list(s)]
    #sorting
    sorted_lvs = {i: purged_lvs[i] for i in range(N)}
    
    return sorted_lvs

def to_plot(genome, sorted_lvs, fixed_nodes):
    """
    from a list generated by sort_levels, this function places nodes from level i-th on the same y-value
    and seperates them.
    Return a dict usable by draw_networks, such as that of nx.spring_layout() for exemple
    coordM = coord on x-axis
    coordN = coord on y-axis
    """
    pos_net = {} #contain positions of each node
    N = len(sorted_lvs)
    if N == 1: coordN = [0]
    else: coordN = np.linspace(-1, 1, N)
    for i in range(N):
        M = len(sorted_lvs[i])
        if M == 1: coordM = [-1]
        else: coordM = np.linspace(-1, 1, M)
        #nb = str(int(np.log10(10)))
        #s = "{0:."+ nb +"f}"
        #r = 1 * float( s.format(random.random()) )
        j = 0
        for node in sorted_lvs[i]:
            ##r = 2 * float(s.format(random.random())) - 1
            ##pos_net[node] = np.array([r, coordN[i]])
            #pos_net[node] = np.array([coordM[j]*r, coordN[i]])
            pos_net[node] = np.array([coordM[j], coordN[i]])
            j += 1
    #fixed nodes
    inp = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "input"]
    out = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "output"]
    I = np.linspace(-1, 1, len(inp)) 
    for e,i in enumerate(inp): pos_net[i] = np.array([0, I[e]])
    pos_net[out[0]] = np.array([0, -1])
    if fixed_nodes != []:
        for n in fixed_nodes:
            if N == 1: coordN = [0]
            else: lv = np.linspace(-1, 1, N)[n[1]]
            pos_net[n[0]] = np.array([n[2], lv])
            
    return pos_net

def layout(genome, fixed_nodes=[]):
    """
    fixed_nodes: list of fixed nodes such as [name, level, x-value]; ex: ["Output", 0,-1]
    return a list of nodes positioned following our script
    """
    out = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "output"]
    inp = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "input"]
    if len(out) + len(inp) > nx.number_of_nodes(genome):
        e = explore(genome, out, [out])
        s = sort_levels(e)
    else:
        s = {}
        s[0] = out
        s[1] = inp
    return to_plot(genome, s, fixed_nodes)
    
def drawing(genome, pos, address, x, y, Xlim, Ylim, ax="off", scores = None):
    """
    address = location of the png in the computer
    x and y = size of the exported png
    pos: node positions following a layout function (layout, spring_layout, shell_layout...)
    """
    plt.figure(figsize=(x*1.12, y*1.19), dpi=100)
    #DRAWING
    nodes = {n: n for n in genome.nodes()}
    inp_nodes = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "input"]
    out_nodes = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "output"]
    gen_nodes = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "gene"]
    pro_nodes = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "protein"]
    com_nodes = [node for (node, dic) in genome.nodes(data = True) if dic["type"] == "complex"]
    tra_edges = [(u, v) for (u, v, dic) in genome.edges(data = True) if dic["effect"] == "transcript"]
    act_edges = [(u, v) for (u, v, dic) in genome.edges(data = True) if dic["effect"] == "activator"]
    rep_edges = [(u, v) for (u, v, dic) in genome.edges(data = True) if dic["effect"] == "repressor"]
    com_edges = [(u, v) for (u, v, dic) in genome.edges(data = True) if dic["effect"] == "complex"]
    
    nx.draw_networkx_nodes(genome, pos, nodelist = inp_nodes, node_color="green", node_size = 1500, node_shape = "p")
    nx.draw_networkx_nodes(genome, pos, nodelist = out_nodes, node_color="red", node_size = 1500, node_shape = "p")
    nx.draw_networkx_nodes(genome, pos, nodelist = gen_nodes, node_color="yellow", node_size = 800, node_shape = "s")
    nx.draw_networkx_nodes(genome, pos, nodelist = pro_nodes, node_color="white",node_size = 800, node_shape = "o")
    nx.draw_networkx_nodes(genome, pos, nodelist = com_nodes, node_color="cyan", node_size = 800, node_shape = "o")
    nx.draw_networkx_labels(genome, pos, labels = nodes, font_weight = "bold")
    nx.draw_networkx_edges(genome, pos, edgelist = tra_edges, edge_color="black")
    nx.draw_networkx_edges(genome, pos, edgelist = act_edges, edge_color="green")
    nx.draw_networkx_edges(genome, pos, edgelist = rep_edges, edge_color="red")
    nx.draw_networkx_edges(genome, pos, edgelist = com_edges, edge_color="blue")

    axes = plt.gca()
    axes.set_xlim(Xlim) #[-2,2]
    axes.set_ylim(Ylim) #[-1.2,1.2]
    if scores is not None:
        s = "Complexity score: " + str(scores[0]) + " -- MSE score: " + str(scores[1]) + " -- Rank: " + str(scores[2])
        plt.title(s, fontsize=15)
        
    plt.axis(ax)
    
   
    plt.savefig(address, bbox_inches='tight', dpi=100)
    plt.clf()
    plt.close()
    
def score_evolution(address, gen_nb, avg, std = None):
    """
    plot evolution of scores according to generations
    gen_nb = number of generations
    avg = [[means of scores at generation 1], ...]
        [means of scores at generation 1] = [[score 1], [score 2]]
    std = such as 'avg' but for standard deviations
    """
    #data
    x = list(range(gen_nb))
    if std is not None:
        cs1 = [avg[0][i] + std[0][i]/2. for i in range(gen_nb)]
        cs2 = [avg[0][i] - std[0][i]/2. for i in range(gen_nb)]
        os1 = [avg[1][i] + std[1][i]/2. for i in range(gen_nb)]
        os2 = [avg[1][i] - std[1][i]/2. for i in range(gen_nb)]
    #plotting
    fig, ax1 = plt.subplots()
    # ax1.set_yscale('log')
    lab1, = ax1.plot(x, avg[0], "r", label="mean of complexity score")
    if std is not None: ax1.fill_between(x, cs1, cs2, color="r", alpha=0.3, linewidth=0)
    ax2 = ax1.twinx()
    ax2.set_yscale('log')
    lab2, = ax2.plot(x, avg[1], "b", label="mean of MSE score")
    if std is not None: ax2.fill_between(x, os1, os2, color="b", alpha=0.3, linewidth=0)
    plt.legend([lab1, lab2], loc = "best")
    ax1.set_xlabel('generations')
    ax1.set_ylabel('complexity score')
    ax2.set_ylabel('MSE score')
    plt.savefig(address, bbox_inches='tight')
    plt.clf()
    plt.close()